<context>
# Overview
FundTuneLab is a research project designed to compare and evaluate different Python libraries for investment portfolio optimization. The project solves the problem of choosing the right optimization approach by providing practical insights into the capabilities, differences, and performance of popular portfolio optimization packages when applied to real-world investment scenarios.

**Target Users**: Individual investors and quantitative researchers looking to understand which optimization library best fits their investment strategy.

**Value Proposition**: Eliminates guesswork in library selection by providing empirical comparison data and practical performance analysis across PyPortfolioOpt, Riskfolio-Lib, and Eiten libraries.

# Core Features

## 1. Multi-Library Portfolio Optimization
**What it does**: Implements identical portfolio optimization workflows using three different Python libraries:
- PyPortfolioOpt (classical efficient frontier, Black-Litterman, Hierarchical Risk Parity)
- Riskfolio-Lib (advanced risk management with multiple risk measures)
- Eiten (quantitative trading and statistical portfolio construction)

**Why it's important**: Different libraries use different mathematical approaches and assumptions, leading to potentially different portfolio allocations for the same input data.

**How it works**: Each library receives identical historical price data and optimization parameters, then generates portfolio weights that can be directly compared.

## 2. Automated Data Collection Pipeline
**What it does**: Downloads and preprocesses historical financial data from Yahoo Finance using the yfinance library.

**Why it's important**: Ensures all optimization libraries work with identical, clean datasets to make comparisons valid and meaningful.

**How it works**: Retrieves OHLCV data for specified assets, handles missing data, and standardizes formats across different date ranges.

## 3. Portfolio Comparison Engine
**What it does**: Analyzes and visualizes differences between portfolio allocations generated by each library.

**Why it's important**: Quantifies how much the different optimization approaches actually differ in practice, identifying which assets each method favors.

**How it works**: Calculates correlations, weight differences, and generates comparison charts to highlight allocation disparities.

## 4. Integrated Backtesting Analysis
**What it does**: Uses existing backtesting capabilities from one of the three libraries to evaluate portfolio performance.

**Why it's important**: Moves beyond theoretical optimization to show real-world performance implications of different approaches.

**How it works**: Applies the best available backtesting framework to portfolios generated by all three methods, calculating risk-adjusted returns and performance metrics.

# User Experience

## User Personas
**Primary User**: Individual investor with Python programming skills who wants to optimize their personal portfolio but is unsure which library to use.

**Secondary User**: Quantitative researcher comparing optimization methodologies for academic or professional purposes.

## Key User Flows
1. **Setup Flow**: Install dependencies via uv → Configure data sources → Verify library installations
2. **Data Collection Flow**: Specify asset universe → Download historical data → Validate data quality
3. **Optimization Flow**: Run optimization scripts for each library → Generate portfolio weights → Save results
4. **Comparison Flow**: Load optimization results → Generate comparison analysis → Visualize differences
5. **Backtesting Flow**: Apply backtesting to all portfolios → Calculate performance metrics → Generate reports

## UI/UX Considerations
- Command-line interface focused on simplicity and automation
- Clear file organization with standardized naming conventions
- Minimal configuration required from user
- Results saved in readable formats (CSV, JSON) for further analysis

</context>
<PRD>
# Technical Architecture

## System Components
- **Data Layer**: Yahoo Finance API integration via yfinance
- **Optimization Layer**: Three separate modules for PyPortfolioOpt, Riskfolio-Lib, and Eiten
- **Comparison Layer**: Analysis engine for portfolio weight comparison
- **Backtesting Layer**: Integration with existing library backtesting capabilities
- **Configuration Layer**: Centralized settings management

## Data Models
- **Price Data**: OHLCV format with standardized date indexing
- **Portfolio Weights**: Normalized weight vectors with asset identifiers
- **Performance Metrics**: Returns, volatility, Sharpe ratio, maximum drawdown
- **Comparison Results**: Correlation matrices and difference calculations

## APIs and Integrations
- **yfinance**: Primary data source for historical prices
- **PyPortfolioOpt**: Classical portfolio optimization methods
- **Riskfolio-Lib**: Advanced risk-based optimization
- **Eiten**: Statistical portfolio construction

## Infrastructure Requirements
- **Programming Language**: Python 3.8+
- **Package Management**: uv exclusively for dependency management
- **Core Dependencies**: PyPortfolioOpt, Riskfolio-Lib, Eiten, yfinance, pandas, numpy, matplotlib
- **Project Structure**:
```
FundTuneLab/
├── data/
│   ├── raw/           # Downloaded price data
│   └── processed/     # Cleaned and formatted data
├── src/
│   ├── data_collection.py
│   ├── pypfopt_optimizer.py
│   ├── riskfolio_optimizer.py
│   ├── eiten_optimizer.py
│   └── comparison.py
├── results/
│   ├── portfolios/    # Generated portfolio weights
│   ├── backtests/     # Backtest results
│   └── reports/       # Analysis reports
├── config/
│   └── settings.py    # Configuration parameters
└── notebooks/         # Jupyter notebooks for exploration
```

# Development Roadmap

## Phase 1: Foundation Setup (MVP)
**Scope**: Create basic project infrastructure and data collection capabilities
**Deliverables**:
- Project structure with uv package management
- Data collection script using yfinance
- Basic configuration management
- Simple data validation and cleaning

**Why this phase**: Establishes the foundation that all other components depend on. Gets data flowing immediately so optimization work can begin.

## Phase 2: Core Optimization Implementation
**Scope**: Implement portfolio optimization for all three libraries
**Deliverables**:
- pypfopt_optimizer.py with mean-variance optimization
- riskfolio_optimizer.py with risk parity methods
- eiten_optimizer.py with statistical approaches
- Standardized input/output formats across all optimizers

**Why this phase**: Core functionality that generates the portfolio weights needed for comparison. Each optimizer is independent, allowing parallel development.

## Phase 3: Comparison and Analysis
**Scope**: Build comparison engine and integrate backtesting
**Deliverables**:
- Portfolio weight comparison analysis
- Visualization of allocation differences
- Integration with best available backtesting library
- Performance comparison reports

**Why this phase**: Transforms raw optimization outputs into actionable insights. Provides the analytical value that justifies the entire project.

# Logical Dependency Chain

## Foundation First (Critical Path)
1. **Project Setup**: Must establish uv environment and basic structure before any library work
2. **Data Collection**: Required before any optimization can occur
3. **Configuration Management**: Needed to standardize parameters across all optimizers

## Parallel Development (Independent)
1. **Library Optimizers**: PyPortfolioOpt, Riskfolio-Lib, and Eiten implementations can be built simultaneously once data pipeline exists
2. **Comparison Framework**: Can be developed alongside optimizers using mock data

## Integration Last (Dependent on Core)
1. **Backtesting Integration**: Requires completed optimizers to generate portfolios for testing
2. **Final Analysis**: Needs both optimization and backtesting results

## Rapid Iteration Strategy
- Start with simplest optimization methods in each library
- Focus on getting end-to-end workflow working with minimal features
- Add complexity and additional optimization methods incrementally
- Prioritize working demonstrations over feature completeness

# Risks and Mitigations

## Technical Challenges
**Risk**: Library compatibility issues between different optimization packages
**Mitigation**: Test each library independently first, then standardize data interfaces

**Risk**: Different input/output formats across libraries requiring complex conversions
**Mitigation**: Create wrapper functions that standardize interfaces early in development

**Risk**: Data quality issues from Yahoo Finance affecting optimization results
**Mitigation**: Implement robust data validation and cleaning procedures

## MVP Definition and Scope
**Risk**: Over-engineering the comparison analysis instead of focusing on core functionality
**Mitigation**: Define MVP as single optimization method per library with basic weight comparison

**Risk**: Spending too much time on visualization instead of core optimization comparison
**Mitigation**: Use simple tabular comparisons initially, add visualizations only after core functionality works

**Risk**: Attempting to implement too many optimization methods simultaneously
**Mitigation**: Start with one method per library (e.g., mean-variance for PyPortfolioOpt, risk parity for Riskfolio-Lib)

## Resource Constraints
**Risk**: Libraries may have steep learning curves delaying implementation
**Mitigation**: Focus on basic functionality first, use library documentation and examples extensively

**Risk**: Backtesting implementation complexity
**Mitigation**: Use existing library capabilities rather than building custom backtesting framework

# Appendix

## Success Criteria
### Technical Success
1. All three libraries successfully installed and functional with uv
2. Data collection pipeline working reliably with Yahoo Finance
3. Portfolio optimization scripts producing valid, comparable outputs
4. Successful integration with existing backtesting capabilities

### Research Success
1. Clear documentation of differences between library approaches
2. Quantified comparison of portfolio allocations
3. Performance analysis showing practical implications of different methods
4. Actionable insights for personal investment strategy selection

## Constraints and Limitations
- Keep implementation simple and focused on comparison rather than production features
- No unit tests or comprehensive test suites required
- Limited to basic visualization and reporting
- Focus on practical application rather than theoretical completeness
- Exclude complex GUI, web interface, or real-time trading features

</PRD>